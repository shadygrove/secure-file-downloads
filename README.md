# Secure File Downloads

This project explores both Front-end and Back-end solutions for enabling secure download links.

It also shows examples of different ways to do a download via the front-end including:  
- Simple anchor tag link
- Anchor with `download` attribute
- HTTP request via Javascript
- HTTP request as "blob" for progress reporting

## Security Mechanism
This project uses the public .NET IdentityServer demo for a authentication.  The application has some routes that are secured with an Angular Guard which will redirect the user to the Identity Server for login credentials.

[https://demo.identityserver.io](https://demo.identityserver.io)  

##  Backend API
The backend API has Authentication enables for all endpoints.  Some controller actions are made public by using the `AllowAnonymous` filter attribute.

# File Download w/ Authentication Summary/Notes

## Problem
Authenticated file downloads are tricky to implement

Providing a direct link to file does not provide the ability to pass an auth token along with the request

## Summary
Possible solutions to authenticate file downloads are:  
* Front-end: Browser-based download using AJAX (not ideal for large files)  
* Front-end: Browser-based download using a[download] (cannot be authenticated other than w/ backend one-time-use token)
* Back-end: one-time-use token generated by server passed as query parameter to download URL.  Download link is not authenticated but the one-time-use token is verified and expires in a short period of time. [Cryptographic nonce](https://en.wikipedia.org/wiki/Cryptographic_nonce)
* Javascript Service Worker to stream file directly to user's file system
* [Angular Service Worker](https://angular.io/guide/service-worker-intro) ]
* Alternative Solution: use a secured file share where the user can get the file.

## Solution 1: Front-end Browser-based Download using AJAX
There is a way to make the request via Javascript and launch a save dialog without redirecting the user.  This would allow passing the token in the request headers.

The data is downloaded as a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)  

### Concerns
This solution downloads the entire Blob into browser memory which may be problematic for large files.

[Blob size limits](https://stackoverflow.com/questions/28307789/is-there-any-limitation-on-javascript-max-blob-size) vary by browser
* (Chrome = 2G Memory; [more info](https://bugs.chromium.org/p/chromium/issues/detail?id=375297#c107)).  
* [See chart here](https://github.com/eligrey/FileSaver.js#supported-browsers).

Refer to [Chrome's Blob Storage Design](https://chromium.googlesource.com/chromium/src/+/HEAD/storage/browser/blob/README.md):  Memory storage is limited to 2G, but it does seem that disk storage is variable based on system storage space.

> If the in-memory space for blobs is getting full, or a new blob is too large to be in-memory, then the blob system uses the disk. This can either be paging old blobs to disk, or saving the new too-large blob straight to disk.

### Resources/Examples:

[Angular File Download with Progress](https://nils-mehlhorn.de/posts/angular-file-download-progress):  
- uses a `download` RxJS operator from library `ngx-operators`  
- file save with [FileSaver.js](https://github.com/eligrey/FileSaver.js) library
- Working [example on StackBlitz](https://stackblitz.com/edit/angular-file-download-progress)  

> FileSaver.js recommends [StreamSaver.js](https://github.com/jimmywarting/StreamSaver.js) for large file downloads using Streams API

The FileSaver docs have an excellent summary file download solutions
[FileSaver.js](https://github.com/eligrey/FileSaver.js/wiki/Saving-a-remote-file)  

Here is a similar but different solution for [File Download with Auth Token](https://blog.theodo.com/2021/03/authenticated-file-download-with-javascript/)

## Solution 2: Service Worker
A service worker can be used to directly download the file to the client.  The token can be passed to the service worker or it can access it directly from localStorage.

Since the Service Worker has elevated access to the user's file system and can write the file stream to disk at it arrives from the backend.

The [StreamSaver.js](https://github.com/jimmywarting/StreamSaver.js) library is designed to perform the download using a Service Worker.

### Concerns
A little more complicated to setup.

Requires use of `fetch` API which would bypass Angular's HttpClient.

[Streaming Large Blob File Using StreamSaver and Angular](https://stackoverflow.com/questions/67776919/stream-large-blob-file-using-streamsaver-js)  
The examples for StreamSaver.js make use of the `fetch()` API which has tha ability to return a stream (experimental feature).  Angular's `HttpClient` does not have that ability.

#### Resources/Examples:  
[StreamSaver.js Doc](https://github.com/jimmywarting/StreamSaver.js)  

[Web Workers vs Service Workers vs Worklets](https://bitsofco.de/web-workers-vs-service-workers-vs-worklets/)  

## Solution 3: Back-end Auth Token
[StackOverflow: How to Handle File Downloads with JWT-based Authentication](https://stackoverflow.com/questions/29452031/how-to-handle-file-downloads-with-jwt-based-authentication)
(note: article is older, 2016)  

One solution suggests using a "signed-request" approach.

We could probably do this by creating and validating our own JWT tokens as explained in this [article](https://dotnetcoretutorials.com/2020/01/15/creating-and-validating-jwt-tokens-in-asp-net-core/)  

The [Hawk protocol](https://github.com/mozilla/hawk/blob/main/API.md) describes an approach for doing this, and there is a Node package for implementation.  There is also a .NET library, [HawkNet](https://www.nuget.org/packages/HawkNet/) - [(GitHub repo)](https://github.com/pcibraro/hawknet) but it does not show active development.

We can probably do this using JWT tools to create and validate single-use tokens.  [This article](https://dotnetcoretutorials.com/2020/01/15/creating-and-validating-jwt-tokens-in-asp-net-core/) shows a good example.

```
using System.IdentityModel.Tokens.Jwt;
```

#### Resources
See this [StackOverflow](https://stackoverflow.com/questions/40281050/jwt-authentication-for-asp-net-web-api)!

As long as this is done correctly, then the a malicious user would need both the URL and the token to access the file.

#### Concerns
The actual download endpoint has to be open to public and manually validate the provided token and expiration timestamp.

## Solution 4: HTTP POST with token
This solution is described in this [Stack Overflow post](https://stackoverflow.com/questions/29452031/how-to-handle-file-downloads-with-jwt-based-authentication)

In summary, the token would be passed via a FORM post that includes the token.  The token is not passed using a Header or via query string.  The backend has to read and validate the token from the POST data.

#### Concerns
The backend download API has to bypass the default authentication methods and take responsibility for token verification.

The download cannot be performed via a direct link.  Must be a coded web HTTP request via Javascript, C#, or similar language.
